package main

import (
	"context"
	"fmt"
	"io/ioutil"
	"net"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"cdr.dev/coder-cli/internal/config"
	"cdr.dev/coder-cli/internal/entclient"
	"github.com/urfave/cli"

	"go.coder.com/flog"
)

func makeConfigSSHCmd() cli.Command {
	var (
		configpath string
		remove     = false
	)

	return cli.Command{
		Name:        "config-ssh",
		Usage:       "Configure SSH to access Coder environments",
		Description: "Inject the proper OpenSSH configuration into your local SSH config file.",
		Action:      configSSH(&configpath, &remove),
		Flags: []cli.Flag{
			cli.StringFlag{
				Name:        "filepath",
				Usage:       "overide the default path of your ssh config file",
				Value:       filepath.Join(os.Getenv("HOME"), ".ssh", "config"),
				TakesFile:   true,
				Destination: &configpath,
			},
			cli.BoolFlag{
				Name:        "remove",
				Usage:       "remove the auto-generated Coder Enterprise ssh config",
				Destination: &remove,
			},
		},
	}
}

func configSSH(filepath *string, remove *bool) func(c *cli.Context) {
	startToken := "# ------------START-CODER-ENTERPRISE-----------"
	startMessage := `# The following has been auto-generated by "coder config-ssh"
# to make accessing your Coder Enterprise environments easier.
#
# To remove this blob, run:
#
#    coder config-ssh --remove
#
# You should not hand-edit this section, unless you are deleting it.`
	endToken := "# ------------END-CODER-ENTERPRISE------------"

	return func(c *cli.Context) {
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		currentConfig, err := readStr(*filepath)
		if os.IsNotExist(err) {
			// SSH configs are not always already there.
			currentConfig = ""
		} else if err != nil {
			flog.Fatal("failed to read ssh config file %q: %v", filepath, err)
		}

		startIndex := strings.Index(currentConfig, startToken)
		endIndex := strings.Index(currentConfig, endToken)

		if *remove {
			if startIndex == -1 || endIndex == -1 {
				flog.Fatal("the Coder Enterprise ssh configuration section could not be safely deleted or does not exist")
			}
			currentConfig = currentConfig[:startIndex-1] + currentConfig[endIndex+len(endToken)+1:]

			err = writeStr(*filepath, currentConfig)
			if err != nil {
				flog.Fatal("failed to write to ssh config file %q: %v", *filepath, err)
			}

			return
		}

		entClient := requireAuth()

		sshAvailable := isSSHAvailable(ctx)
		if !sshAvailable {
			flog.Fatal("SSH is disabled or not available for your Coder Enterprise deployment.")
		}

		me, err := entClient.Me()
		if err != nil {
			flog.Fatal("failed to fetch username: %v", err)
		}

		envs := getEnvs(entClient)
		if len(envs) < 1 {
			flog.Fatal("no environments found")
		}
		newConfig, err := makeNewConfigs(me.Username, envs, startToken, startMessage, endToken)
		if err != nil {
			flog.Fatal("failed to make new ssh configurations: %v", err)
		}

		// if we find the old config, remove those chars from the string
		if startIndex != -1 && endIndex != -1 {
			currentConfig = currentConfig[:startIndex-1] + currentConfig[endIndex+len(endToken)+1:]
		}

		err = writeStr(*filepath, currentConfig+newConfig)
		if err != nil {
			flog.Fatal("failed to write new configurations to ssh config file %q: %v", filepath, err)
		}
		err = writeSSHKey(ctx, entClient)
		if err != nil {
			flog.Fatal("failed to fetch and write ssh key: %v", err)
		}

		fmt.Printf("An auto-generated ssh config was written to %q\n", *filepath)
		fmt.Printf("Your private ssh key was written to %q\n", privateKeyFilepath)
		fmt.Println("You should now be able to ssh into your environment")
		fmt.Printf("For example, try running\n\n\t$ ssh coder.%s\n\n", envs[0].Name)
	}
}

var (
	privateKeyFilepath = filepath.Join(os.Getenv("HOME"), ".ssh", "coder_enterprise")
)

func writeSSHKey(ctx context.Context, client *entclient.Client) error {
	key, err := client.SSHKey()
	if err != nil {
		return err
	}
	return ioutil.WriteFile(privateKeyFilepath, []byte(key.PrivateKey), 0400)
}

func makeNewConfigs(userName string, envs []entclient.Environment, startToken, startMsg, endToken string) (string, error) {
	hostname, err := configuredHostname()
	if err != nil {
		return "", nil
	}

	newConfig := fmt.Sprintf("\n%s\n%s\n\n", startToken, startMsg)
	for _, env := range envs {
		newConfig += makeSSHConfig(hostname, userName, env.Name)
	}
	newConfig += fmt.Sprintf("\n%s\n", endToken)

	return newConfig, nil
}

func makeSSHConfig(host, userName, envName string) string {
	return fmt.Sprintf(
		`Host coder.%s
   HostName %s
   User %s-%s
   StrictHostKeyChecking no
   ConnectTimeout=0
   IdentityFile=%s
   ServerAliveInterval 60
   ServerAliveCountMax 3
`, envName, host, userName, envName, privateKeyFilepath)
}

func isSSHAvailable(ctx context.Context) bool {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	host, err := configuredHostname()
	if err != nil {
		return false
	}

	var dialer net.Dialer
	_, err = dialer.DialContext(ctx, "tcp", net.JoinHostPort(host, "22"))
	return err == nil
}

func configuredHostname() (string, error) {
	u, err := config.URL.Read()
	if err != nil {
		return "", err
	}
	url, err := url.Parse(u)
	if err != nil {
		return "", err
	}
	return url.Hostname(), nil
}

func writeStr(filename, data string) error {
	return ioutil.WriteFile(filename, []byte(data), 0777)
}

func readStr(filename string) (string, error) {
	contents, err := ioutil.ReadFile(filename)
	if err != nil {
		return "", err
	}
	return string(contents), nil
}
